/* tslint:disable */
/* eslint-disable */
/**
 * geoip/v1/service.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Geoipv1Location
 */
export interface Geoipv1Location {
    /**
     * 
     * @type {number}
     * @memberof Geoipv1Location
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Geoipv1Location
     */
    'longitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof Geoipv1Location
     */
    'timeZone'?: string;
    /**
     * 
     * @type {number}
     * @memberof Geoipv1Location
     */
    'metroCode'?: number;
    /**
     * 
     * @type {number}
     * @memberof Geoipv1Location
     */
    'accuracyRadius'?: number;
}
/**
 * 
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof ProtobufAny
     */
    '@type'?: string;
}
/**
 * 
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
    /**
     * 
     * @type {number}
     * @memberof RpcStatus
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof RpcStatus
     */
    'message'?: string;
    /**
     * 
     * @type {Array<ProtobufAny>}
     * @memberof RpcStatus
     */
    'details'?: Array<ProtobufAny>;
}
/**
 * 
 * @export
 * @interface V1AnonymousIp
 */
export interface V1AnonymousIp {
    /**
     * 
     * @type {string}
     * @memberof V1AnonymousIp
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1AnonymousIp
     */
    'network'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1AnonymousIp
     */
    'isAnonymous'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1AnonymousIp
     */
    'isAnonymousVpn'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1AnonymousIp
     */
    'isHostingProvider'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1AnonymousIp
     */
    'isPublicProxy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1AnonymousIp
     */
    'isResidentialProxy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1AnonymousIp
     */
    'isTorExitNode'?: boolean;
}
/**
 * 
 * @export
 * @interface V1Asn
 */
export interface V1Asn {
    /**
     * 
     * @type {string}
     * @memberof V1Asn
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Asn
     */
    'network'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Asn
     */
    'autonomousSystemNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Asn
     */
    'autonomousSystemOrganization'?: string;
}
/**
 * 
 * @export
 * @interface V1City
 */
export interface V1City {
    /**
     * 
     * @type {V1CityRecord}
     * @memberof V1City
     */
    'cityRecord'?: V1CityRecord;
    /**
     * 
     * @type {V1Continent}
     * @memberof V1City
     */
    'continent'?: V1Continent;
    /**
     * 
     * @type {V1CountryRecord}
     * @memberof V1City
     */
    'country'?: V1CountryRecord;
    /**
     * 
     * @type {V1CountryRecord}
     * @memberof V1City
     */
    'registeredCountry'?: V1CountryRecord;
    /**
     * 
     * @type {V1RepresentedCountry}
     * @memberof V1City
     */
    'representedCountry'?: V1RepresentedCountry;
    /**
     * 
     * @type {Geoipv1Location}
     * @memberof V1City
     */
    'location'?: Geoipv1Location;
    /**
     * 
     * @type {V1CityPostal}
     * @memberof V1City
     */
    'postal'?: V1CityPostal;
    /**
     * 
     * @type {Array<V1CitySubdivision>}
     * @memberof V1City
     */
    'subdivisions'?: Array<V1CitySubdivision>;
    /**
     * 
     * @type {V1CityTraits}
     * @memberof V1City
     */
    'traits'?: V1CityTraits;
}
/**
 * 
 * @export
 * @interface V1CityPostal
 */
export interface V1CityPostal {
    /**
     * 
     * @type {string}
     * @memberof V1CityPostal
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface V1CityRecord
 */
export interface V1CityRecord {
    /**
     * 
     * @type {string}
     * @memberof V1CityRecord
     */
    'geonameId'?: string;
    /**
     * 
     * @type {V1Names}
     * @memberof V1CityRecord
     */
    'names'?: V1Names;
}
/**
 * 
 * @export
 * @interface V1CitySubdivision
 */
export interface V1CitySubdivision {
    /**
     * 
     * @type {V1Names}
     * @memberof V1CitySubdivision
     */
    'names'?: V1Names;
    /**
     * 
     * @type {string}
     * @memberof V1CitySubdivision
     */
    'isoCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CitySubdivision
     */
    'geonameId'?: string;
}
/**
 * 
 * @export
 * @interface V1CityTraits
 */
export interface V1CityTraits {
    /**
     * 
     * @type {boolean}
     * @memberof V1CityTraits
     */
    'isAnycast'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1CityTraits
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CityTraits
     */
    'network'?: string;
}
/**
 * 
 * @export
 * @interface V1ConnectionType
 */
export interface V1ConnectionType {
    /**
     * 
     * @type {string}
     * @memberof V1ConnectionType
     */
    'connectionType'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConnectionType
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1ConnectionType
     */
    'network'?: string;
}
/**
 * 
 * @export
 * @interface V1Continent
 */
export interface V1Continent {
    /**
     * 
     * @type {V1Names}
     * @memberof V1Continent
     */
    'names'?: V1Names;
    /**
     * 
     * @type {string}
     * @memberof V1Continent
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Continent
     */
    'geonameId'?: string;
}
/**
 * 
 * @export
 * @interface V1Country
 */
export interface V1Country {
    /**
     * 
     * @type {V1Continent}
     * @memberof V1Country
     */
    'continent'?: V1Continent;
    /**
     * 
     * @type {V1CountryRecord}
     * @memberof V1Country
     */
    'country'?: V1CountryRecord;
    /**
     * 
     * @type {V1CountryRecord}
     * @memberof V1Country
     */
    'registeredCountry'?: V1CountryRecord;
    /**
     * 
     * @type {V1RepresentedCountry}
     * @memberof V1Country
     */
    'representedCountry'?: V1RepresentedCountry;
    /**
     * 
     * @type {V1CountryTraits}
     * @memberof V1Country
     */
    'traits'?: V1CountryTraits;
}
/**
 * 
 * @export
 * @interface V1CountryRecord
 */
export interface V1CountryRecord {
    /**
     * 
     * @type {V1Names}
     * @memberof V1CountryRecord
     */
    'names'?: V1Names;
    /**
     * 
     * @type {string}
     * @memberof V1CountryRecord
     */
    'isoCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CountryRecord
     */
    'geonameId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1CountryRecord
     */
    'isInEuropeanUnion'?: boolean;
}
/**
 * 
 * @export
 * @interface V1CountryTraits
 */
export interface V1CountryTraits {
    /**
     * 
     * @type {boolean}
     * @memberof V1CountryTraits
     */
    'isAnycast'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1CountryTraits
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1CountryTraits
     */
    'network'?: string;
}
/**
 * 
 * @export
 * @interface V1Domain
 */
export interface V1Domain {
    /**
     * 
     * @type {string}
     * @memberof V1Domain
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Domain
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Domain
     */
    'network'?: string;
}
/**
 * 
 * @export
 * @interface V1Enterprise
 */
export interface V1Enterprise {
    /**
     * 
     * @type {V1Continent}
     * @memberof V1Enterprise
     */
    'continent'?: V1Continent;
    /**
     * 
     * @type {Array<V1EnterpriseSubdivision>}
     * @memberof V1Enterprise
     */
    'subdivisions'?: Array<V1EnterpriseSubdivision>;
    /**
     * 
     * @type {V1EnterprisePostal}
     * @memberof V1Enterprise
     */
    'postal'?: V1EnterprisePostal;
    /**
     * 
     * @type {V1RepresentedCountry}
     * @memberof V1Enterprise
     */
    'representedCountry'?: V1RepresentedCountry;
    /**
     * 
     * @type {V1EnterpriseCountryRecord}
     * @memberof V1Enterprise
     */
    'country'?: V1EnterpriseCountryRecord;
    /**
     * 
     * @type {V1CountryRecord}
     * @memberof V1Enterprise
     */
    'registeredCountry'?: V1CountryRecord;
    /**
     * 
     * @type {V1EnterpriseCityRecord}
     * @memberof V1Enterprise
     */
    'city'?: V1EnterpriseCityRecord;
    /**
     * 
     * @type {Geoipv1Location}
     * @memberof V1Enterprise
     */
    'location'?: Geoipv1Location;
    /**
     * 
     * @type {V1EnterpriseTraits}
     * @memberof V1Enterprise
     */
    'traits'?: V1EnterpriseTraits;
}
/**
 * 
 * @export
 * @interface V1EnterpriseCityRecord
 */
export interface V1EnterpriseCityRecord {
    /**
     * 
     * @type {V1Names}
     * @memberof V1EnterpriseCityRecord
     */
    'names'?: V1Names;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseCityRecord
     */
    'geonameId'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1EnterpriseCityRecord
     */
    'confidence'?: number;
}
/**
 * 
 * @export
 * @interface V1EnterpriseCountryRecord
 */
export interface V1EnterpriseCountryRecord {
    /**
     * 
     * @type {V1Names}
     * @memberof V1EnterpriseCountryRecord
     */
    'names'?: V1Names;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseCountryRecord
     */
    'isoCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseCountryRecord
     */
    'geonameId'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1EnterpriseCountryRecord
     */
    'confidence'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof V1EnterpriseCountryRecord
     */
    'isInEuropeanUnion'?: boolean;
}
/**
 * 
 * @export
 * @interface V1EnterprisePostal
 */
export interface V1EnterprisePostal {
    /**
     * 
     * @type {string}
     * @memberof V1EnterprisePostal
     */
    'code'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1EnterprisePostal
     */
    'confidence'?: number;
}
/**
 * 
 * @export
 * @interface V1EnterpriseSubdivision
 */
export interface V1EnterpriseSubdivision {
    /**
     * 
     * @type {V1Names}
     * @memberof V1EnterpriseSubdivision
     */
    'names'?: V1Names;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseSubdivision
     */
    'isoCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseSubdivision
     */
    'geonameId'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1EnterpriseSubdivision
     */
    'confidence'?: number;
}
/**
 * 
 * @export
 * @interface V1EnterpriseTraits
 */
export interface V1EnterpriseTraits {
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseTraits
     */
    'network'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseTraits
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseTraits
     */
    'autonomousSystemOrganization'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseTraits
     */
    'connectionType'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseTraits
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseTraits
     */
    'isp'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseTraits
     */
    'mobileCountryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseTraits
     */
    'mobileNetworkCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseTraits
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseTraits
     */
    'userType'?: string;
    /**
     * 
     * @type {number}
     * @memberof V1EnterpriseTraits
     */
    'staticIpScore'?: number;
    /**
     * 
     * @type {string}
     * @memberof V1EnterpriseTraits
     */
    'autonomousSystemNumber'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1EnterpriseTraits
     */
    'isAnycast'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof V1EnterpriseTraits
     */
    'isLegitimateProxy'?: boolean;
}
/**
 * 
 * @export
 * @interface V1GetAnonymousIpResponse
 */
export interface V1GetAnonymousIpResponse {
    /**
     * 
     * @type {V1AnonymousIp}
     * @memberof V1GetAnonymousIpResponse
     */
    'anonymousIp'?: V1AnonymousIp;
}
/**
 * 
 * @export
 * @interface V1GetAsnResponse
 */
export interface V1GetAsnResponse {
    /**
     * 
     * @type {V1Asn}
     * @memberof V1GetAsnResponse
     */
    'asn'?: V1Asn;
}
/**
 * 
 * @export
 * @interface V1GetCityResponse
 */
export interface V1GetCityResponse {
    /**
     * 
     * @type {V1City}
     * @memberof V1GetCityResponse
     */
    'city'?: V1City;
}
/**
 * 
 * @export
 * @interface V1GetConnectionTypeResponse
 */
export interface V1GetConnectionTypeResponse {
    /**
     * 
     * @type {V1ConnectionType}
     * @memberof V1GetConnectionTypeResponse
     */
    'connectionType'?: V1ConnectionType;
}
/**
 * 
 * @export
 * @interface V1GetCountryResponse
 */
export interface V1GetCountryResponse {
    /**
     * 
     * @type {V1Country}
     * @memberof V1GetCountryResponse
     */
    'country'?: V1Country;
}
/**
 * 
 * @export
 * @interface V1GetDomainResponse
 */
export interface V1GetDomainResponse {
    /**
     * 
     * @type {V1Domain}
     * @memberof V1GetDomainResponse
     */
    'domain'?: V1Domain;
}
/**
 * 
 * @export
 * @interface V1GetEnterpriseResponse
 */
export interface V1GetEnterpriseResponse {
    /**
     * 
     * @type {V1Enterprise}
     * @memberof V1GetEnterpriseResponse
     */
    'enterprise'?: V1Enterprise;
}
/**
 * 
 * @export
 * @interface V1GetIspResponse
 */
export interface V1GetIspResponse {
    /**
     * 
     * @type {V1Isp}
     * @memberof V1GetIspResponse
     */
    'isp'?: V1Isp;
}
/**
 * 
 * @export
 * @interface V1GetMyIpResponse
 */
export interface V1GetMyIpResponse {
    /**
     * 
     * @type {string}
     * @memberof V1GetMyIpResponse
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1GetMyIpResponse
     */
    'detectedFrom'?: string;
}
/**
 * 
 * @export
 * @interface V1Isp
 */
export interface V1Isp {
    /**
     * 
     * @type {string}
     * @memberof V1Isp
     */
    'network'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Isp
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Isp
     */
    'autonomousSystemOrganization'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Isp
     */
    'isp'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Isp
     */
    'mobileCountryCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Isp
     */
    'mobileNetworkCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Isp
     */
    'organization'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Isp
     */
    'autonomousSystemNumber'?: string;
}
/**
 * 
 * @export
 * @interface V1Names
 */
export interface V1Names {
    /**
     * 
     * @type {string}
     * @memberof V1Names
     */
    'de'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Names
     */
    'en'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Names
     */
    'es'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Names
     */
    'fr'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Names
     */
    'ja'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Names
     */
    'ptBr'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Names
     */
    'ru'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1Names
     */
    'zhCn'?: string;
}
/**
 * 
 * @export
 * @interface V1RepresentedCountry
 */
export interface V1RepresentedCountry {
    /**
     * 
     * @type {V1Names}
     * @memberof V1RepresentedCountry
     */
    'names'?: V1Names;
    /**
     * 
     * @type {string}
     * @memberof V1RepresentedCountry
     */
    'isoCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof V1RepresentedCountry
     */
    'geonameId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V1RepresentedCountry
     */
    'isInEuropeanUnion'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V1RepresentedCountry
     */
    'type'?: string;
}

/**
 * GeoIPServiceApi - axios parameter creator
 * @export
 */
export const GeoIPServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetAnonymousIp: async (ipAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipAddress' is not null or undefined
            assertParamExists('geoIPServiceGetAnonymousIp', 'ipAddress', ipAddress)
            const localVarPath = `/v1/geoip/anonymous-ip/{ipAddress}`
                .replace(`{${"ipAddress"}}`, encodeURIComponent(String(ipAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetAsn: async (ipAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipAddress' is not null or undefined
            assertParamExists('geoIPServiceGetAsn', 'ipAddress', ipAddress)
            const localVarPath = `/v1/geoip/asn/{ipAddress}`
                .replace(`{${"ipAddress"}}`, encodeURIComponent(String(ipAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetCity: async (ipAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipAddress' is not null or undefined
            assertParamExists('geoIPServiceGetCity', 'ipAddress', ipAddress)
            const localVarPath = `/v1/geoip/city/{ipAddress}`
                .replace(`{${"ipAddress"}}`, encodeURIComponent(String(ipAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetConnectionType: async (ipAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipAddress' is not null or undefined
            assertParamExists('geoIPServiceGetConnectionType', 'ipAddress', ipAddress)
            const localVarPath = `/v1/geoip/connection-type/{ipAddress}`
                .replace(`{${"ipAddress"}}`, encodeURIComponent(String(ipAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetCountry: async (ipAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipAddress' is not null or undefined
            assertParamExists('geoIPServiceGetCountry', 'ipAddress', ipAddress)
            const localVarPath = `/v1/geoip/country/{ipAddress}`
                .replace(`{${"ipAddress"}}`, encodeURIComponent(String(ipAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetDomain: async (ipAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipAddress' is not null or undefined
            assertParamExists('geoIPServiceGetDomain', 'ipAddress', ipAddress)
            const localVarPath = `/v1/geoip/domain/{ipAddress}`
                .replace(`{${"ipAddress"}}`, encodeURIComponent(String(ipAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetEnterprise: async (ipAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipAddress' is not null or undefined
            assertParamExists('geoIPServiceGetEnterprise', 'ipAddress', ipAddress)
            const localVarPath = `/v1/geoip/enterprise/{ipAddress}`
                .replace(`{${"ipAddress"}}`, encodeURIComponent(String(ipAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetIsp: async (ipAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipAddress' is not null or undefined
            assertParamExists('geoIPServiceGetIsp', 'ipAddress', ipAddress)
            const localVarPath = `/v1/geoip/isp/{ipAddress}`
                .replace(`{${"ipAddress"}}`, encodeURIComponent(String(ipAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetMyIp: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/geoip/myip`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeoIPServiceApi - functional programming interface
 * @export
 */
export const GeoIPServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeoIPServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoIPServiceGetAnonymousIp(ipAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetAnonymousIpResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geoIPServiceGetAnonymousIp(ipAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoIPServiceApi.geoIPServiceGetAnonymousIp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoIPServiceGetAsn(ipAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetAsnResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geoIPServiceGetAsn(ipAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoIPServiceApi.geoIPServiceGetAsn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoIPServiceGetCity(ipAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetCityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geoIPServiceGetCity(ipAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoIPServiceApi.geoIPServiceGetCity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoIPServiceGetConnectionType(ipAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetConnectionTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geoIPServiceGetConnectionType(ipAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoIPServiceApi.geoIPServiceGetConnectionType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoIPServiceGetCountry(ipAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetCountryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geoIPServiceGetCountry(ipAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoIPServiceApi.geoIPServiceGetCountry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoIPServiceGetDomain(ipAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetDomainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geoIPServiceGetDomain(ipAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoIPServiceApi.geoIPServiceGetDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoIPServiceGetEnterprise(ipAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetEnterpriseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geoIPServiceGetEnterprise(ipAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoIPServiceApi.geoIPServiceGetEnterprise']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoIPServiceGetIsp(ipAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetIspResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geoIPServiceGetIsp(ipAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoIPServiceApi.geoIPServiceGetIsp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geoIPServiceGetMyIp(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetMyIpResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geoIPServiceGetMyIp(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoIPServiceApi.geoIPServiceGetMyIp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GeoIPServiceApi - factory interface
 * @export
 */
export const GeoIPServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeoIPServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetAnonymousIp(ipAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<V1GetAnonymousIpResponse> {
            return localVarFp.geoIPServiceGetAnonymousIp(ipAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetAsn(ipAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<V1GetAsnResponse> {
            return localVarFp.geoIPServiceGetAsn(ipAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetCity(ipAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<V1GetCityResponse> {
            return localVarFp.geoIPServiceGetCity(ipAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetConnectionType(ipAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<V1GetConnectionTypeResponse> {
            return localVarFp.geoIPServiceGetConnectionType(ipAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetCountry(ipAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<V1GetCountryResponse> {
            return localVarFp.geoIPServiceGetCountry(ipAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetDomain(ipAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<V1GetDomainResponse> {
            return localVarFp.geoIPServiceGetDomain(ipAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetEnterprise(ipAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<V1GetEnterpriseResponse> {
            return localVarFp.geoIPServiceGetEnterprise(ipAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ipAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetIsp(ipAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<V1GetIspResponse> {
            return localVarFp.geoIPServiceGetIsp(ipAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geoIPServiceGetMyIp(options?: RawAxiosRequestConfig): AxiosPromise<V1GetMyIpResponse> {
            return localVarFp.geoIPServiceGetMyIp(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeoIPServiceApi - object-oriented interface
 * @export
 * @class GeoIPServiceApi
 * @extends {BaseAPI}
 */
export class GeoIPServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} ipAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoIPServiceApi
     */
    public geoIPServiceGetAnonymousIp(ipAddress: string, options?: RawAxiosRequestConfig) {
        return GeoIPServiceApiFp(this.configuration).geoIPServiceGetAnonymousIp(ipAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ipAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoIPServiceApi
     */
    public geoIPServiceGetAsn(ipAddress: string, options?: RawAxiosRequestConfig) {
        return GeoIPServiceApiFp(this.configuration).geoIPServiceGetAsn(ipAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ipAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoIPServiceApi
     */
    public geoIPServiceGetCity(ipAddress: string, options?: RawAxiosRequestConfig) {
        return GeoIPServiceApiFp(this.configuration).geoIPServiceGetCity(ipAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ipAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoIPServiceApi
     */
    public geoIPServiceGetConnectionType(ipAddress: string, options?: RawAxiosRequestConfig) {
        return GeoIPServiceApiFp(this.configuration).geoIPServiceGetConnectionType(ipAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ipAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoIPServiceApi
     */
    public geoIPServiceGetCountry(ipAddress: string, options?: RawAxiosRequestConfig) {
        return GeoIPServiceApiFp(this.configuration).geoIPServiceGetCountry(ipAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ipAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoIPServiceApi
     */
    public geoIPServiceGetDomain(ipAddress: string, options?: RawAxiosRequestConfig) {
        return GeoIPServiceApiFp(this.configuration).geoIPServiceGetDomain(ipAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ipAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoIPServiceApi
     */
    public geoIPServiceGetEnterprise(ipAddress: string, options?: RawAxiosRequestConfig) {
        return GeoIPServiceApiFp(this.configuration).geoIPServiceGetEnterprise(ipAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ipAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoIPServiceApi
     */
    public geoIPServiceGetIsp(ipAddress: string, options?: RawAxiosRequestConfig) {
        return GeoIPServiceApiFp(this.configuration).geoIPServiceGetIsp(ipAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoIPServiceApi
     */
    public geoIPServiceGetMyIp(options?: RawAxiosRequestConfig) {
        return GeoIPServiceApiFp(this.configuration).geoIPServiceGetMyIp(options).then((request) => request(this.axios, this.basePath));
    }
}



