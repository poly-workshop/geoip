// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: geoip/v1/service.proto

package geoip_v1_pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GeoIPService_GetMyIp_FullMethodName           = "/geoip.v1.GeoIPService/GetMyIp"
	GeoIPService_GetCity_FullMethodName           = "/geoip.v1.GeoIPService/GetCity"
	GeoIPService_GetCountry_FullMethodName        = "/geoip.v1.GeoIPService/GetCountry"
	GeoIPService_GetEnterprise_FullMethodName     = "/geoip.v1.GeoIPService/GetEnterprise"
	GeoIPService_GetAnonymousIp_FullMethodName    = "/geoip.v1.GeoIPService/GetAnonymousIp"
	GeoIPService_GetAsn_FullMethodName            = "/geoip.v1.GeoIPService/GetAsn"
	GeoIPService_GetConnectionType_FullMethodName = "/geoip.v1.GeoIPService/GetConnectionType"
	GeoIPService_GetDomain_FullMethodName         = "/geoip.v1.GeoIPService/GetDomain"
	GeoIPService_GetIsp_FullMethodName            = "/geoip.v1.GeoIPService/GetIsp"
)

// GeoIPServiceClient is the client API for GeoIPService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GeoIPServiceClient interface {
	GetMyIp(ctx context.Context, in *GetMyIpRequest, opts ...grpc.CallOption) (*GetMyIpResponse, error)
	GetCity(ctx context.Context, in *GetCityRequest, opts ...grpc.CallOption) (*GetCityResponse, error)
	GetCountry(ctx context.Context, in *GetCountryRequest, opts ...grpc.CallOption) (*GetCountryResponse, error)
	GetEnterprise(ctx context.Context, in *GetEnterpriseRequest, opts ...grpc.CallOption) (*GetEnterpriseResponse, error)
	GetAnonymousIp(ctx context.Context, in *GetAnonymousIpRequest, opts ...grpc.CallOption) (*GetAnonymousIpResponse, error)
	GetAsn(ctx context.Context, in *GetAsnRequest, opts ...grpc.CallOption) (*GetAsnResponse, error)
	GetConnectionType(ctx context.Context, in *GetConnectionTypeRequest, opts ...grpc.CallOption) (*GetConnectionTypeResponse, error)
	GetDomain(ctx context.Context, in *GetDomainRequest, opts ...grpc.CallOption) (*GetDomainResponse, error)
	GetIsp(ctx context.Context, in *GetIspRequest, opts ...grpc.CallOption) (*GetIspResponse, error)
}

type geoIPServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGeoIPServiceClient(cc grpc.ClientConnInterface) GeoIPServiceClient {
	return &geoIPServiceClient{cc}
}

func (c *geoIPServiceClient) GetMyIp(ctx context.Context, in *GetMyIpRequest, opts ...grpc.CallOption) (*GetMyIpResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMyIpResponse)
	err := c.cc.Invoke(ctx, GeoIPService_GetMyIp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoIPServiceClient) GetCity(ctx context.Context, in *GetCityRequest, opts ...grpc.CallOption) (*GetCityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCityResponse)
	err := c.cc.Invoke(ctx, GeoIPService_GetCity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoIPServiceClient) GetCountry(ctx context.Context, in *GetCountryRequest, opts ...grpc.CallOption) (*GetCountryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCountryResponse)
	err := c.cc.Invoke(ctx, GeoIPService_GetCountry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoIPServiceClient) GetEnterprise(ctx context.Context, in *GetEnterpriseRequest, opts ...grpc.CallOption) (*GetEnterpriseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEnterpriseResponse)
	err := c.cc.Invoke(ctx, GeoIPService_GetEnterprise_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoIPServiceClient) GetAnonymousIp(ctx context.Context, in *GetAnonymousIpRequest, opts ...grpc.CallOption) (*GetAnonymousIpResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAnonymousIpResponse)
	err := c.cc.Invoke(ctx, GeoIPService_GetAnonymousIp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoIPServiceClient) GetAsn(ctx context.Context, in *GetAsnRequest, opts ...grpc.CallOption) (*GetAsnResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAsnResponse)
	err := c.cc.Invoke(ctx, GeoIPService_GetAsn_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoIPServiceClient) GetConnectionType(ctx context.Context, in *GetConnectionTypeRequest, opts ...grpc.CallOption) (*GetConnectionTypeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetConnectionTypeResponse)
	err := c.cc.Invoke(ctx, GeoIPService_GetConnectionType_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoIPServiceClient) GetDomain(ctx context.Context, in *GetDomainRequest, opts ...grpc.CallOption) (*GetDomainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDomainResponse)
	err := c.cc.Invoke(ctx, GeoIPService_GetDomain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geoIPServiceClient) GetIsp(ctx context.Context, in *GetIspRequest, opts ...grpc.CallOption) (*GetIspResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetIspResponse)
	err := c.cc.Invoke(ctx, GeoIPService_GetIsp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GeoIPServiceServer is the server API for GeoIPService service.
// All implementations must embed UnimplementedGeoIPServiceServer
// for forward compatibility.
type GeoIPServiceServer interface {
	GetMyIp(context.Context, *GetMyIpRequest) (*GetMyIpResponse, error)
	GetCity(context.Context, *GetCityRequest) (*GetCityResponse, error)
	GetCountry(context.Context, *GetCountryRequest) (*GetCountryResponse, error)
	GetEnterprise(context.Context, *GetEnterpriseRequest) (*GetEnterpriseResponse, error)
	GetAnonymousIp(context.Context, *GetAnonymousIpRequest) (*GetAnonymousIpResponse, error)
	GetAsn(context.Context, *GetAsnRequest) (*GetAsnResponse, error)
	GetConnectionType(context.Context, *GetConnectionTypeRequest) (*GetConnectionTypeResponse, error)
	GetDomain(context.Context, *GetDomainRequest) (*GetDomainResponse, error)
	GetIsp(context.Context, *GetIspRequest) (*GetIspResponse, error)
	mustEmbedUnimplementedGeoIPServiceServer()
}

// UnimplementedGeoIPServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGeoIPServiceServer struct{}

func (UnimplementedGeoIPServiceServer) GetMyIp(context.Context, *GetMyIpRequest) (*GetMyIpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMyIp not implemented")
}
func (UnimplementedGeoIPServiceServer) GetCity(context.Context, *GetCityRequest) (*GetCityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCity not implemented")
}
func (UnimplementedGeoIPServiceServer) GetCountry(context.Context, *GetCountryRequest) (*GetCountryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCountry not implemented")
}
func (UnimplementedGeoIPServiceServer) GetEnterprise(context.Context, *GetEnterpriseRequest) (*GetEnterpriseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEnterprise not implemented")
}
func (UnimplementedGeoIPServiceServer) GetAnonymousIp(context.Context, *GetAnonymousIpRequest) (*GetAnonymousIpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAnonymousIp not implemented")
}
func (UnimplementedGeoIPServiceServer) GetAsn(context.Context, *GetAsnRequest) (*GetAsnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAsn not implemented")
}
func (UnimplementedGeoIPServiceServer) GetConnectionType(context.Context, *GetConnectionTypeRequest) (*GetConnectionTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectionType not implemented")
}
func (UnimplementedGeoIPServiceServer) GetDomain(context.Context, *GetDomainRequest) (*GetDomainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDomain not implemented")
}
func (UnimplementedGeoIPServiceServer) GetIsp(context.Context, *GetIspRequest) (*GetIspResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIsp not implemented")
}
func (UnimplementedGeoIPServiceServer) mustEmbedUnimplementedGeoIPServiceServer() {}
func (UnimplementedGeoIPServiceServer) testEmbeddedByValue()                      {}

// UnsafeGeoIPServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GeoIPServiceServer will
// result in compilation errors.
type UnsafeGeoIPServiceServer interface {
	mustEmbedUnimplementedGeoIPServiceServer()
}

func RegisterGeoIPServiceServer(s grpc.ServiceRegistrar, srv GeoIPServiceServer) {
	// If the following call pancis, it indicates UnimplementedGeoIPServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GeoIPService_ServiceDesc, srv)
}

func _GeoIPService_GetMyIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMyIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoIPServiceServer).GetMyIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeoIPService_GetMyIp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoIPServiceServer).GetMyIp(ctx, req.(*GetMyIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoIPService_GetCity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoIPServiceServer).GetCity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeoIPService_GetCity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoIPServiceServer).GetCity(ctx, req.(*GetCityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoIPService_GetCountry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCountryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoIPServiceServer).GetCountry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeoIPService_GetCountry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoIPServiceServer).GetCountry(ctx, req.(*GetCountryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoIPService_GetEnterprise_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEnterpriseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoIPServiceServer).GetEnterprise(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeoIPService_GetEnterprise_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoIPServiceServer).GetEnterprise(ctx, req.(*GetEnterpriseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoIPService_GetAnonymousIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAnonymousIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoIPServiceServer).GetAnonymousIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeoIPService_GetAnonymousIp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoIPServiceServer).GetAnonymousIp(ctx, req.(*GetAnonymousIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoIPService_GetAsn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAsnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoIPServiceServer).GetAsn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeoIPService_GetAsn_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoIPServiceServer).GetAsn(ctx, req.(*GetAsnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoIPService_GetConnectionType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConnectionTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoIPServiceServer).GetConnectionType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeoIPService_GetConnectionType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoIPServiceServer).GetConnectionType(ctx, req.(*GetConnectionTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoIPService_GetDomain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoIPServiceServer).GetDomain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeoIPService_GetDomain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoIPServiceServer).GetDomain(ctx, req.(*GetDomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeoIPService_GetIsp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIspRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeoIPServiceServer).GetIsp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeoIPService_GetIsp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeoIPServiceServer).GetIsp(ctx, req.(*GetIspRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GeoIPService_ServiceDesc is the grpc.ServiceDesc for GeoIPService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GeoIPService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "geoip.v1.GeoIPService",
	HandlerType: (*GeoIPServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMyIp",
			Handler:    _GeoIPService_GetMyIp_Handler,
		},
		{
			MethodName: "GetCity",
			Handler:    _GeoIPService_GetCity_Handler,
		},
		{
			MethodName: "GetCountry",
			Handler:    _GeoIPService_GetCountry_Handler,
		},
		{
			MethodName: "GetEnterprise",
			Handler:    _GeoIPService_GetEnterprise_Handler,
		},
		{
			MethodName: "GetAnonymousIp",
			Handler:    _GeoIPService_GetAnonymousIp_Handler,
		},
		{
			MethodName: "GetAsn",
			Handler:    _GeoIPService_GetAsn_Handler,
		},
		{
			MethodName: "GetConnectionType",
			Handler:    _GeoIPService_GetConnectionType_Handler,
		},
		{
			MethodName: "GetDomain",
			Handler:    _GeoIPService_GetDomain_Handler,
		},
		{
			MethodName: "GetIsp",
			Handler:    _GeoIPService_GetIsp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "geoip/v1/service.proto",
}
